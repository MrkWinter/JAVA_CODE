### ideal使用技巧

##### 基本技巧及介绍

> 可以设置字体、颜色主题、字符编码 
>
> 在idea 当run一个程序时 会先编译成class文件再运行
>
> src 是源码文件  out存放编译后的class文件 

##### 快捷键（可自定义）

>
>
>1. ctrl + d 拷贝当前行到下一行
>
>2. ctrl + y 删除当前行
>3. alt + / **补全代码**
>4. ctrl + / 注释代码
>5. alt + enter 自动导入包 (使用类未导入包时，光标在类上输入---- idea设置先配置可以自动导入)
>6. ctrl+ ait + l 自动快速格式化代码 (自动对齐)
>7. shift + f10 快速运行程序
>8. alt+insert 快速生成构造器 (ctrl + a 全选 shift 选择  这个快捷方法可以给类中属性生成构造方法 访问方法 修改方法)
>9. ctrl + h **查看类的继承关系**
>10. ctrl + b 定位方法位置
>11. .var自动分配变量名 (如new Scanner(System.in).var  alt + enter 也能自动分配变量名)

##### java模板 (可自定义模板)

> main (主函数生成)
>
> sout  (输入语句生成--System.out.printf("");)
>
> fori (for循环生成)
>
> foreach (增强for循环)

### 包

##### 包与引入包的语法

> 1. 打包：package 包名   如: package com.aabb
>    package 是关键字  表示打包 com.aabb 是包名
>    package 放在代码的最上面
>
> 2. 引入包：import 包名  如: import com.aabb
>
>    import 是关键字 表示引入包  引入包后才能使用包中的类
>
>    inport放在package的下面 类定义之前 表示引入包
>
>    import java.util.Scanner; //导入java.util 下的Scanner类
>
>    import java.util.* //导入java.util下的所有的类
>
>    一般使用那种类就导入那种类 不建议使用*
>
> 

##### 包的命名

> 1. 包由字母数字下划线 小数点组成  
>
> 2. 不能是数字开头 包名一般是小写字母
>
> 3. 命名规范： com.公司名.项目名.业务模块名
>
>    如：
>
>    com.sina.crm.user //用户模块
>    com.sina.crm.order //订单模块
>    com.sina.crm.utils //工具类

##### 包的其他细节

> 1. 包的本质
>
>    包的本质就是创建不同的文件夹/目录 来保存类文件
>
>    com.qing 中.是下级目录的意思 qing是一个包 
>
>    里面可以放很多的java文件 java文件中可以放很多个类 
>
>    com是一个大包 包中有很多个小包
>
> 2. 包的作用
>
>    区分同名的类
>
>    当类很多时 可以更好的管理类
>
>    控制访问范围
>
> 3. 常用的包
>
>    java.long 基本包默认引入 有Math
>    java.util 系统提供的工具包  有Scanner
>    java.net  网络包
>    java.awt  java界面开发 GUL

### 访问修饰符

##### 访问修饰符的种类

>各个访问修饰符的访问范围是
>
>|           | 同类 | 同包   | 子类   | 不同包 |
>| --------- | ---- | ------ | ------ | ------ |
>| public    | 可以 | 可以   | 可以   | 可以   |
>| protected | 可以 | 可以   | 可以   | 不可以 |
>| 默认(无)  | 可以 | 可以   | 不可以 | 不可以 |
>| private   | 可以 | 不可以 | 不可以 | 不可以 |
>
>细节
>
>修饰符可以修饰类中的成员属性 成员方法 以及类
>只有默认和public可以修饰类
>成员方法 属性 类的访问规则相同

### 封装

##### 封装的介绍

> 封装就是把抽象出来的数据(属性) 和对数据的操作(方法) 封装在一起 数据被保护在内部
>
> 程序的其他部分只有通过被授权的操作（方法）  才能对数据进行操作

##### 封装的好处

> 可以隐藏细节 可以对数据进行验证 保证安全合理

##### 封装的实现步骤

> 三步走 
>
> 属性设置为私有  
>
> 设置public方法可以修改设置属性  
>
> 设置public方法可以获取得到属性
>
> tip：求字符串长度可用  字符串.length 

##### 封装和构造器

> 将set方法写在构造器中 可以防止构造器随意修改属性 
>
> 使有的属性必须使用设置方法来设置 保护属性的安全性
>
> 可以使用快捷键 alt + insert 快速生成设置属性方法

### 继承

##### 继承介绍

> 有时候两个类的属性和方法是相同的 这时继承来解决代码的重复性问题 提高代码的复用性
>
> 将类相同的地方抽象成父类(基类 ,超类)   父类中定义子类（派生类）相同的属性和方法
>
> 然后就用extends让子类继承父类  子类可以继承父类中的属性和方法 
>
> 然后子类中定义特有的属性和方法  这样就是继承的体现   注意：一个子类同样可以当父类

##### 继承细节

> 1.  子类继承了所有的方法和属性  相当于将代码从父类中移动到子类
>
>    非私有的方法和属性可以在子类中访问  
>
>    私有的方法和属性不可以在子类直接中访问（可以用在父类中public 的方法访问对应的属性和方法）
>
> 2. 子类必须调用父类的构造器 完成父类的初始化 
>
>    (因为子类中包含父类的属性信息 创建子类时 会自动调用构造器 构造器中有super()方法)
>
> 3. 创建子类时无论使用那个构造器 都会自动先去调用父类的无参构造器
>
>    如果父类没有无参构造器 则需要在子类构造器中用super指定是那个父类构造器
>
>    总之要完成父类的初始化 因为要继承属性和方法
>
> 4. 如果希望调用父类的某个构造器 则显示的定义一下 super（参数列表）
>
> 5. super在使用时必须放在第一行 super() 和 this() 都只能在构造器中使用
>
> 6. super 和 this 都只能放在第一行 所以一个构造器中只能有一个this 或 super
>
> 7. java 所有类都是object 的子类
>
> 8. 父类构造器的调用不限于直接父类 将一直往上追溯到object 顶级父类
>
>    也就是会不断追溯到到那顶级父类 先将依次将父类进行初始化
>
>    （java 中定义一个类若果没有显式定义父类 没有继承一个父类 那么这个类默认继承object类)
>
> 9. 子类只能继承一个父类(指直接继) java中是单继承机制 
>
> 10. 不能滥用继承 继承必须合理

##### 继承本质

> 代码分析
>
> ```java
> public class Test {
>     public static void main(String[] args) {
>         Son s1 = new Son();
>     }
> }
> class Grandfather { //爷类
>     String name = "中头爷爷";
>     String hobby = "打篮球";
> }
> class Father extends Grandfather { //父类
>     String name = "小头爸爸";
>     int age;
> }
> class Son extends Father { //子类
>     String name = "大头儿子";
> }
> 
> ```
>
> 创建子类对象时  系统会先在jvm虚拟机的方法区依次加载object类的信息   Grandfather爷类的的信息   Father类的信息   Son类的信息    根据类在堆区开辟存储对象s1的空间   然后将Grandfather爷类中属性的name 和 hobby存储在堆区  （注意堆区储存的是字符串的地址 是先在方法区的常量池开辟空间后返回地址到堆区储存）  然后将Father类的属性name 和 age 存储到堆区  （字符串为引用类型数据 堆区储存的还是地址  引用类型数据有 对象 数组 字符串 传递时是地址）  最将Son类的name属性存储到堆区  最后这一整块区域的地址返回给在栈区开辟一块空间的s1  s1是该对象的引用

##### 子类中属性的访问

> 查找关系：
>
> 1. 先看子类有无该属性 
> 2. 若有 并且可以访问 则返回信息
> 3. 如果子类没有这个属性 就看父类中有无该属性 同第二条
> 4. 若父类无该属性 同第三条 继续找父类 直到object类
> 5. 查找关系只查找一个 若查到private属性 不能访问 往上还有同名public属性 则不可访问
>
> 综上  访问遵循以子类为起点就近原则 

##### super关键字

> 1. super可以访问父类的属性 但不能访问private属性 super.属性名
>
>    super可以访问父类的方法 但不能访问private方法 super.方法名(参数列表)
>
>    super可以访问父类的构造器 但只能放到子类构造器的第一行 super(参数列表)
>
> 2. super代表父类的引用 用于访问父类的属性方法和构造器 在子类有重名问题时可以直接调用父类  解决了子类中直接提到的属性 方法 访问遵循就近原则的问题 有时可不用super（子类中与父类无重名时） 子类中使用this 也是就近原则
>
> 3. super的访问不限于直接父类 如果爷爷类和本类中有同名的成员 也可以使用super去访问爷爷类的成员 如果多个基类中都有同名的成员 使用super遵循就近原则 super可以理解为父类的引用
>
> 综上 在有继承的子类中寻找属性 方法 构造器（构造器只能使用 2 3）的方式有  1 直接提到 ==  2 this关键字 （从子类开始查找） 3 super关键字 （从父类开始查找）
>
> 构造器的调用方式： super this  （super在子类构造器中必须使用  this在构造器中调用构造器时不能使用super）
>
> 方法和属性调用方式： 直接调用    this    super   （this和直接调用从子类开始查找 然后到父类 直到查找到对应的数据  若数据可使用 则调用该数据 若未查到或查到不能使用 则报错 ）

##### 方法的重写

> 1. 基本介绍及作用
>
>    ```c
>    //子类中有和父类中方法名相同的方法
>    //并且方法的定义形式 （名称 参数 返回类型）相同
>    //这时称子类的方法重写了父类的方法 叫方法的重写 覆盖
>    作用：高代码的复用性
>    ```
>
> 2. 细节
>
>    1. 重写的方法的名称 形式参数列表 要相同
>    2. 子类方法的返回类型和父类方法的返回类型要一样 或者子类方法的返回类型是父类方法返回类型的子类 如父类返回object 子类返回String  
>    3. 子类方法不能缩小父类方法的访问权限 如父类是public 子类不能是 private 可以扩大 不能缩小

### 多态

##### 前言引入

> 当一个类中用特定的方法调用多个对象时如果对象不同 则定义的方不同 这样不利于代码的维护
>
> 并且复用性不高 -->引出多态  
>
> 解释：多态 多种状态  方法和对象有多种状态 是面向对象的三大特征 多态是建立在封装和继承之上的

##### 多态的体现

> 1. 方法的重载（一个方法名根据参数列表不同有不同的状态 （方法））
>
> 2. 方法的重写 子类和父类中有同名方法 但形态（内容）不同  (一个以参数列表不同形式来区分调用不同的方法  一个用父类和子类来区分调用不同的方法)
>
> 3. 对象的多态  (根据运行类型和编译类型不同实现  javac时关联编译类型 java时关联运行类型)
>    1. 一个对象的编译类型和运行类型可以不一致 
>    
>    2. 编译类型再定义对象时就确定了 不能改变
>    
>    3. 运行类型是可以改变的
>    
>    4. 编译类型看等号的左边 运行类型看等号的右边
>    
>       实例：
>    
>       ``` java
>       public class Test {
>           public static void main(String[] args) {
>               //对象多态的简单体现 Dog 和 Cat 是Animal的子类
>               //可以把创建的子类对象的引用赋给父类对象的引用
>               // ad1是对象animal的引用
>               // Animal 是ad1的编译类型    Dog是ad1的运行类型
>               //ad1是披着羊皮的狼
>               //运行时是运行类型决定
>               Animal ad1 = new Dog();
>               ad1.cry(); //输出狗叫
>               // ad1的运行类型被改成了 Cat 也就是ad1的指向指向了堆区的Cat 运行时看指向的堆区对象
>               ad1 = new Cat();
>               ad1.cry(); //输出猫叫
>           }
>       }
>       ```
>    
>       对象的多态实际就是父类对象引用的编译类型和运行类型可以不一致 也就是说父类对象的引用可以接收子类对象 这时父类对象编译类型为父类 运行类型为子类 父类运行类型有多种形态 就是对象的多态
>    
>    5. 注意事项
>    
>       多态的前提是  对象(类) 存在继承关系

##### 多态的向上转型

>   本质: 父类的引用指向了子类的对象 
>
>   语法: 父类类型 引用名 = new 子类类型() 
>
> 特点: 
>
> 1. 编译类型看左边 运行类型看右边
> 2. 可以访问父类的成员 但需要遵循访问权限
> 3. 不可以调用子类中特有的成员 （可以调用子类中重写的方法)
> 4. 最终的运行效果看子类
>
> 解释：
>
> （ 因为在编译阶段，决定能调用那些成员，是有编译类型来决定的 而编译类型为父类的编译类型编译阶段只有父类被编译 子类中特有的成员属性 方法 不能访问 但最终的运行效果看子类的具体实现  因为运行阶段会先看子类的类的信息 访问方法时也是从子类开始 若子类有父类重写的方法 则访问子类的方法） 调用看编译类型 运行看运行类型 所以只能找到父类的属性和方法 运行时从子类开始查找
>

##### 多态的向下转型

> 向下转型的基础是向上转型
>
> 1. 语法 子类类型 引用名 = （子类类型） 父类引用
> 2. 只能强转父类的引用 不能强转父类的类型   也就是父类的引用必须是由子类向上转型的父类的引用
> 3. 要求父类的引用必须指向的是当前类型的对象
> 4. 向下转型后 就可以访问子类的成员

##### 向上转型和向下转型的总结】

> 1. 可以用父类的引用指向子类对象 此时引用名的编译类型为父类  运行类型为子类 这称作向上转型  编译时 因为编译类型是父类 所以只能访问父类的成员  但在运行时 因为运行类型为子类 可能是jvm机中有子类的信息  所以访问时从子类开始访问 也就是实际运行时先看子类 是否有父类中可以识别的成员 
> 2. 因为向上转型有局限 当想访问子类特有的成员时 可以将向上转型的引用名强制转换成该引用名指向对象的类型  这时编译类型为对应的子类 运行类型为对应的子类 编译时可以识别到子类的成员 访问时也是从对应的子类中开始寻找
>
> tip:属性没有重写之说 属性值看编译类型 -- 访问属性看编译类型 访问方法看运行类型
>
> ```java
> public class Test {
>     public static void main(String[] args) {
>         Base s1 = new Sub(); //编译类型为Base
>         System.out.println(s1.age); //10
>         Sub s2 = new Sub(); //编译类型为Sub
>         System.out.println(s2.age); //20
>         //综上 属性没有重写之说 属性值看编译类型 编译了才能访问
>         //若s2无age 也能访问父类的age 是因为继承关系 编译子类的同时
>         //编译了父类 而上面对象多态的向上转型 只编译父类
>         //向下转型编译子类  所以向下转型和创建的普通的子类对象相似 都能访问父类
>     }
> ```
>
> instanceof 比较操作符 判断对象的运行类型是否为XX类型或XX的子类型
>
> 语法： 对象引用 instanceof 类名 对返回true 错返回 false 

##### java动态绑定机制

> 内容: 
>
> 1. 当第一次调用对象的方法时候 该方法会和该对象的内存地址/运行类型绑定
> 2. 当在调用对象的属性时 没有动态绑定机制 哪里声明哪里使用
> 3. 就是访问属性看编译类型 访问方法看运行类型
> 4. 当调用该对象的方法时 该方法会和对象的内存地址运行类型进行动态绑定  就是调用对象方法看运行类型 
> 5. 调用对象的属性时 没有动态绑定机制  哪里声明哪里使用 就是不用看运行类型 哪里声明哪里使用

#####  多态数组 

>1. 数组名(引用)的定义类型为父类类型 里面保存的时间元素为子类类型
>2. 多态数组 实质就是可以利用向上转型和向下转型的机制 先将父类或子类对象存入以父类为数据类型的数组中 利用向上转型或者向下转型 不断访问对象 提高访问对象的效率 提高代码的复用性
>3. 数组存储代码实例
>
>```java
>public class Poly {
>    public static void main(String[] args) {
>        Person p1 = new Person("zhao", 18);
>        Person s1 = new Student("shun", 20, 90);
>        Person s2 = new Student("wang", 19, 100);
>        Person w1 = new Worker("shan", 21, 3000);
>        Person w2 = new Worker("li", 28, 6000);
>        //利用向上转型定义五个对象 可以存入多态数组
>        Person[] people = {p1,s1,s2,w1,w2}; //创建多态数组
>        for(int i = 0;i<people.length;i++) {
>            System.out.println(people[i].say());//利用多态数组 循环访问对象
>        }
>    }
>}
>```
>
>4. 访问子类代码实例  
>
>```java
>//因为编译类型为父类 所以找不到子类中的方法
>//如何访问子类中特有元素？ -- 向下转型
>//先用instanceof来判断运行类型是否为要调用子类对象的类型 如果是 向下转型 来访问子类成员 //如果是 向下转型 来访问子类成员
>if(people[i] instanceof Student) {
>    Student temp = (Student)people[i];
>    System.out.println(temp.show());
>}
>if(people[i] instanceof Worker) {
>    Worker temp = (Worker)people[i];
>    System.out.println(temp.show());
>}
>```

##### 多态参数

>1. 方法定义的形参可以为父类类型 实参允许为子类类型
>2. 多态参数 就是在方法中把子类作为实参 父类作为形参接收 然后将对象根据向上转型和向下转型的机制 进行访问对应父类或子类对象的方法或属性
>3. 代码实例
>
>```java
>public void showAnnual(Employee e) {
>    System.out.println(e.getAnnual());  //向上转型 子类重写父类方法 返回对象的工资
>}
>public void showWork(Employee e) {
>    if(e instanceof Worker) {
>        System.out.println(((Worker) e).showWork());//展示工人的工作信息
>    } else if(e instanceof Manager) {
>        System.out.println(((Manager) e).showWork());
>    }
>}
>```

### object类中的方法

> object类是所有类的超类 所有对象都可以调用该类中的方法
>
> tip：idea 使用技巧 ctrl + 鼠标左键 查看源码

##### equals方法

>1. 常和 == 做比较  == 可以判断基本数据类型 又可以判断引用类型
>2. 如果判断基本数据类型 则判断值是否相等
>3. 如果判断引用类型 则判断的是地址 即判断是不是同一个对象 
>4. equals 是object类中的方法 只能判断引用类型 默认判断的是地址是否相同 子类(integer) (string)类中往往重写了该方法 用于判断内容是否相等
>
>```java
>public class Equals {
>    public static void main(String[] args) {
>        System.out.println("liming".equals("wang"));//false
>        Integer integer1 = new Integer(5);
>        Integer integer2 = new Integer(5);
>        System.out.println(integer1 == integer2);//false ==对引用类型判断地址
>        System.out.println(integer1.equals(integer2));//true 判断值相等
>    }
>}
>```

##### hashCode方法

>作用:
>
>1. 提高具有哈希结构的容器系效率
>2. 两个引用如果指向的是同一个对象 则哈希值肯定是一样的
>3. 两个引用如果指向的是不同对象 则哈希值是不一样的
>4. 哈希值主要根据地址（内部地址）来的 但不完全等价于地址 

##### toString方法

>介绍:
>
>默认返回 全类名 + @ + 哈希值的16进制 （Object中的原方法）
>
>细节:
>
>打印对象或拼接对象时 都会自动调用对象的toString方法 相当于toString代表了对象的信息

##### finalize方法

>1. 当对象被回收时 会自动调用finalize方法 子类可以重写该方法 做一些资源的释放
>2. 对象无引用时认为对象是一个垃圾 
>3.  垃圾回收机制的调用 由系统来决定（不显示） 可通过System.gc() 来主动调用

### 断点调试 （debug） 

>断点调试 （debug） 要先打断点再debug
>
>基本介绍:
>
>1. F7(跳入 跳进方法)
>2. alt + shift + F7  （强制进入  追源码）
>3. F8(跳过 逐句执行)
>4. F8+shift(跳出 跳出循环 方法)
>5. F9(resume 跳到下个断点)
>
>tip: 小技巧 将光标放到数据上可以快速看到数据

### 零钱通知识

##### Date 类

> java.util.Date包下的Date类 用该类创建对象可以获得当前日期 但获得的是国外格式的日期
>
> 用法 Date date = new Date();  直接打印date对象 会 自动调用该对象的 toString方法 打印当前时间信息？

##### SimpleDateFormat类

>java.text.SimpleDateFormat 包下的SimpleDate类 用该类创建对象 该类中有一个方法可以使Date类对象
>
>的日期格式改变
>
>用法 SimpleDateFormat sdf = new SImpleDateFormat("yyyy-MM-dd HH:mm");
>
>System.out.println(sdf.format(date)); //打印对应格式的日期

* 编程思想 

  > 在处理业务时 尽量找不正确的地方 较容易 挑刺容易 找对难

* 面向对象的思想

  >以零钱通为例 将零钱通视为类 将全局变量变为该类中的成员属性
  >
  >将显示零钱通明细 收益入账 消费出账 退出变为该类中的四个成员方法
  >
  >然后定义一个成员方法（显示零钱通菜单选项并使用） 包含容纳使用以上四个方法
  >
  >使用该类时直接创建对象 调用零钱通的方法 

* 练习与总结

>```java
> //多态 方法或对象有多种形态 是oop的第三大特征 是建立在封装和继承之上的
>        //1方法多态
>        //(1)方法的重载 (2)方法的重写
>        //2对象多态
>        //(1)对象（引用）的运行类型和编译类型可以不一样 编译类型在定义时就确定 不能改变
>        //(2)型是可以改变的，通过getClass方法来获取对象运行类型
>        //(3)编译类型看 = 左边 运行类型看 = 右边
>        
>        Person p1 = new Student("wag", 'm', 23, "2232");
>        //p1对象 的编译类型为Person 不能改变
>        Student s11 = (Student) p1; //向下转型是重新定义了一个对象(引用)
>        Person a1 = new LittleStudent("wag", 'm', 23, "2232");
>        System.out.println(a1.getClass());
>        //向上转型 父类的引用可以指向子类的对象 向下转型 向上转型对象的引用可以强转为子类对象的引用,代表子类对象
>        a1 = new Student("wag", 'm', 23, "2232");
>        System.out.println(a1.getClass());
>        //父类的引用可以来回切换子类 即父类的引用可以来回指向子类
>        Student c1 = new LittleStudent("wag", 'm', 23, "2232");
>        a1 = c1;
>        System.out.println(a1.getClass());
>       
>```

### 房屋出租系统 

> java分层编写代码
>
> 界面层view 业务层service 数据层domain

##### utility类的使用 （工具类）

>当一个方法是static时 就是一个静态方法
>
>可以直接通过类名.方法名进行调用 静态公用 不用创建对象 也就是每个对象中的都一样
