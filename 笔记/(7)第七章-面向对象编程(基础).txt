1 类与对象

java设计者引入类与对象(oop)  根本原因是现有的技术不能完美的解决现有的问题 

一个程序就是一个世界 有很多事物(对象) 对象由属性和行为构成

提取多个相似对象的特征 组成了一个类 如很多种猫组成了一个猫类 一个猫类中定义了很多种猫的属性 和 行为 

类是一种自定义数据类型 其中定义了 属性 和 行为 使用类可以创建一个对象 如猫类可以创建一个对象猫 

综上 类就是数据类型 对象是类的一个具体的实例 类是对象的一个模板 对象是类的一个个体 对应一个实例  

从类到对象 有以下几种说法 1 创建一个对象 2 实例化一个对象 3 把类实例化 等

2.类的对象的存储

创建类的对象时 会在方法区 加载类的信息 这些信息有属性和方法 

该对象名为栈区的一块内存地址 该地址指向堆区的一块大的空间存放对象的属性和行为 (方法信息)

字符串类型为引用类型 会在堆区继续存储地址 地址指向方法区的常量池开辟的内存 储存字符串

3.属性概念

属性 也叫成员变量 字段  属性是类的组成部分

类中的属性可以是基本数据类型 也可以是引用类型(对象/数组/字符串)

访问修饰符：控制属性的访问范围 四种 public proctected 默认 private 示例 访问修饰符 属性类型 属性名

属性如果不赋值 会有默认值 规则和数组一致

4.对象细节

创建People 对象 真正的对象是堆里面的
People p1 = new People();  p1 是对象名 代指对象 而不是对象本体 是对对象的引用  new People()创建的对象空间(数据)才是真正的对象
一个对象可能有多个对象名 同时指向堆区的空间(对象)

5.对象和类的使用方式

创建对象方式

方式1 Cat cat1； cat1 = new Cat();   Cat cat1后在栈区开辟一块内存放null new 后该内存存放在堆区开辟对象的内存的地址

方式2 Cat cat1 = new Cat()；

访问属性方式

对象名.属性名 如cat.name


6.类和对象的内存分配机制

字符串类型 定义的为字符串常量 存储在方法区的常量池


class Person {
	String name;
	int age;
}
public class test_3_10 {
	public static void main(String[] args) {
		Person s1 = new Person();
		s1.name = "小明";
		s1.age = 18;
		Person s2 = s1;
		s2.name = "小花";
		System.out.print(s1.name);
	}
}

分析代码

Person s1 = new Person();
1 创建一个对象时 类会加载到方法区 然后根据类中定义的属性在堆区开辟内存存储对象的属性 属性为默认值 然后将开辟内存的地址传给对象名 在栈区存储起来
若属性中有字符串类型等引用类型 会在开辟的内存中存储地址 指向方法区的常量池 (字符串类型定义的为字符串常量)
s1.name = "小明";
s1.age = 18;
2 给对象属性符值时 根据对象名存储的地址 找到对象 修改属性
Person s2 = s1;
3 将 s1赋给s2 让s2指向s1 也就是直接在堆区开辟内存存储地址 该地址指向s1 指向的对象 等于一个对象有两个引用
s2.name = "小花";
System.out.print(s1.name);
对象名s2 和 s1 都指向同一个对象 s2更改 s1也会更改

java创建对象的流程简单分析

先加载类信息(属性和方法信息 类信息是类的模板 只会加载一次) 然后再堆中分配空间 进行默认初始化

然后把地址赋给对象的引用名(对象名) 最后进行指定初始化

7.jvm内存分配及使用

栈：一般存放基本数据类型(局部变量)

堆：存放对象 数组等

方法区：常量池(常量，比如字符串) 类加载信息 



8.类中方法的使用

class Person {
	String name;
	int age;
	public void speak() {
		System.out.println("我是一个好人");
	}
}
//解释 类中有方法 也叫成员方法 
// public 表示方法是公开的
// void 表示方法返回值为空
// speak() speak 是方法名 ()是参数列表
// {} 方法体可以写我们运行的代码

调用方法时 要先创建一个类的对象 然后用

对象名.成员方法名() 来调用方法

计算机会去在该类中找到该方法 执行该方法中的代码

9.类中方法使用细节

可以定义方法  public void speak(int n) 括号中可以定义形式参数 调用时可以传参

方法的定义和c语言函数相同 只是有访问修饰符 

方法的调用和c语言函数相似  调用函数时要先创建对象 再用.调用对应的方法

任何类中都可以有main方法

10.方法调用机制解释
public cal{
public int cal03(int a,int b) {
		return a+b;
	}
}
public class test_3_11 {
public static void main(String[] args) {	
	cal c1 = new cal();
	int ret = c1.cal03(10,20)
	System.out.print(ret);
  }
}
//程序开始时 main方法进入栈区
//1 cal c1 = new cal() 执行时 用cal类创建对象 对象储存在堆区
//2 int ret = c1.cal03(10,20) 执行时 调用c1.cal03 方法 该方法压入栈区 并将10 和 20
//传递给方法 （） 中的a 和 b 该方法结束后  该方法出栈 将结果a+b返回到原调用函数的地方
//3 System.out.print(ret); 打印结果

总结 

当程序执行到方法时 就会开辟一个独立的空间(栈空间)
当方法进行完毕后 或者执行到return语句时 就会返回
返回到调用方法的地方
返回后 继续执行方法后的代码
当main函数方(栈)法执行完毕 整个程序就会退出

11.成员方法定义

public 返回数据类型 方法名 （形参列表）{方法体语句 return 返回值

}；

12.成员方法使用细节

返回值相关：
一个方法只能返回一个值 （如何返回多个值 ？ ———— 返回数组）
返回类型可以是任意类型 包含基本数据类型和引用类型 如数组和对象等
如果方法中定义了返回类型   则方法体中最后的执行语句必须是retrun 值  方法返回类型必须和return后的值类型一致或兼容
如果方法中定义返回值为void 这方法体中可以不写return 或者 直接写return；
方法名 小驼峰定义法 首字母小写 其他单词第一个字母大写 其他小写

形参列表相关：
一个成员方法可以有0个或多个形参
参数类型可以是任意类型 包含基本数据类型和引用类型 如 void printarr(int[][] arr)
调用成员方法时实参和形参必须类型一致或兼容 并且个数统一一致

方法体相关：
方法中可以为输入，输出，循环，运算，分支，方法调用等 但是不能进行方法定义
方法定义时不能套娃 这点和c语言函数相同 函数里面不能定义函数

方法调用相关：
同一个类中的方法可以直接调用 不用创建对象
跨类中的方法调用要先创建对象 在通过 对象名.方法名()来调用

方法传参相关：
方法调用直接进行基本数据类型的数据传参 进行的是值传递 形参变化不改变实际参数
方法调用进行引用类型的数据的传参 （数组 字符串 对象等）进行的是地址传递 形参变化改变实际参数  在根本上是通过相同的地址找到相同的空间进行操作

12.方法递归调用

方法递归： 类中成员方法自己调用自己的情况

方法递归会不断在栈区中加载方法的新栈 如果使用不当 会导致栈溢出

递归必须向递归结束的条件逼近 方法定义的有返回值时结束时最后一定要有返回值 这点与c语言不同

递归的理解 ： 递归的核心思想就是层级思想 就是把复杂的问题分层思考 只思考每一层的实现方法

然后重复调用 直到解决问题  也就是大事化小 消失化了 递归方法实现时最重要的是要思考递归结束的条件 即最后一步

13.方法的重载

好处减轻了起名的好处 减少了记名的麻烦

方法重载就是在类中可以同时定义多个方法名相同的方法 但方法的返回类型 形式参数类型及个数及顺序不同 

创建完对象后调用时根据传参不同 自动识别来调用特点的方法

细节 方法名必须相同 形参的类型 或个数 或顺序 至少有一个不一样      参数名不要求相同 返回类型不影响 也就是返回类型和参数名不能区别方法

方法传参时 会根据较符合参数类型进行调用方法  若无较匹配时数据  可以进行强制类型转换的方法也可以调用



14.可变参数

class Methods {

	public int sum(int...nums) {
		int sum = 0;
		for(int i = 0;i<nums.length;i++) {
			sum+= nums[i];
		}
		return sum;
	}
}
public class test_3_13 {
	public static void main(String[] args) {
		Methods s1 = new Methods();
		System.out.println("总和为" + s1.sum(1,2,3,4));
	}
}

	计算1 2 3 4 个数的和 对应方法  方法重载 但较麻烦无意义
	功能相同 可变参数不同 可使用可变参数
	可变参数定义 数据类型...变量名
	int...sums 表示接收的是可变参数 相当于有0~n个参数 类型为int
	使用参数时 可以当成数组来使用 nums可当成数组


细节 可变参数的个数可以是0 或 任意个 

可变参数的实际参数可以是数组 

可变参数的本质就是数组

可变参数和普通参数都可以放入形式参数列表 但可变参数必须放在最后

一个形式参数列表最多只能有一个可变参数  方法可以直接返回一个字符串

15.作用域基本使用

java变量主要分为 （属性）成员(全局)变量和局部变量
全局变量 （属性）      作用域是整个类体 属性在定义时可以直接赋值
局部变量 除了属性之外的变量 代码块是其作用域
全局变量 可以不赋值使用 因为有初始值
局部变量不能不赋值使用

细节 属性和局部变量可以重名 使用遵循就近原则

同一类中的属性 不能重名 属性的生命周期较长随对象创建开始 随对象销毁而结束 

局部变量的生命周期较短  从定义而开始 伴随代码块的结束而销毁

更多细节

全局变量(属性)可以在类中使用 也可被他类使用 (通过创建对象调用) （通过传递对象使用）
局部变量 只能在本类中对应的方法中使用
全局变量可以加修饰符
局部变量不可以加修饰符

16.构造器(构造方法)

语法 [修饰符] 方法名 (形参列表) {
       方法体；
}

构造器是类中的一种特殊的方法 它的主要作用是完成对对象的初始化 有以下几个特点

方法名和类名相同 

无返回值

在创建对象时 系统会自动调用该类的构造器完成对对象的初始化

参数列表和成员方法一样

更多更多细节

一个类中可以定义多种构造器 即构造器的重载

构造器不能用对象调用 而是使用时系统自动调用

如果未定义构造器 系统会自动生成一个无参构造器 (默认构造器)

如果定义了构造器 那么默认构造器就会被覆盖 创建对象时就不能使用无参构造器

若还想用无参构造器 则需要显式定义一


、、案例分析


class Person{
	int age = 90;
	String name;
	Person(String n,int a) {
		name = n;
		age = a;
	}
}
public class Test_3_14 {
	public static void main(String[] args) {
		Person p = new Person("xiao",20);
		//new对象时 Person类会先加载到方法区 然后再在堆区开辟内存 
		//内存中有age name等属性 默认初始化值分别为0和null
		//Person类中的age属性有显式初始化 age的值变成了90
		//再往后调用构造器 将"xiao" 和 20 分别传递到n 和 a中 再赋给类中的属性name和age
		//属性name赋值时 "xiao" 的内存开辟在方法区的常量池中 类在堆区中的name存储"xiao"的地址
		//age从新赋值了20
		//以上 new开辟的对象初始化完成 
		//然后再在栈区中开辟空间 存储堆区类内存的地址 p是地址 是对象的引用 而不是对象
	}
} 


17.this 关键字

this可以解决对象初始化时构造器的形参和属性名相同的问题 this代表创建的当前对象的属性

this的理解this相当于储存在对象中对对象本身的引用 相当于对象名 this指向创建的本身的对象

this -->  我

那个对象调用 this就代表那个对象

细节

this关键字可以用来访问本类的属性 方法 构造器  this.属性 是指定对象的属性

this用于区分当前类的属性和局部变量

访问成员的方法的语法 this.方法名(参数列表)

访问构造器语法 this(参数列表) （注意只能在构造器中使用 即只能在一个构造器中访问另外一个构造器） 相当于构造器的继承？

注意如果用this访问构造器语法 必须在构造器的第一行

this只能在类定义的方法中使用 与对象关联


匿名对象 

只能用一次 使用后就不能被使用 会被自动销毁
new 对象.方法 

创建对象后直接调用方法
