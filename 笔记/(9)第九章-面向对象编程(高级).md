### 类变量和类方法

1. 类变量  static修饰的变量 静态变量

* 类变量的定义

> 类变量也叫静态变量/静态属性 ，是该类的所有对象共享的一个变量，任何一个该类的对象去访问它时，取到的都是相同的值，任何一个对象修改它时，修改的也是同一个变量

* static变量存储位置

> //两种说法
> // 1类变量存放在堆空间 新
> // 2类变量存放在方法区的静态域 旧

* 类变量的定义语法及属性访问

> 定义：
>
> 访问修饰符 static 数据类型 变量名 （推荐）
>
> static 访问修饰符 数据类型 变量名
>
> 访问：
>
> 类名.类变量
>
> 对象名.类变量   （可能不能使用）

* 类变量的细节

> 类变量是所有对象共享的 普通成员变量(实例变量)是每个成员独享的的
>
> 实例变量不能使用类名.变量名来访问
>
> 类变量在类初始化时就存在了 不创建对象也能访问静态变量
>
> 类变量的生命周期随类加载开始 到类消亡摧毁

2. 类方法 静态方法

* 类方法的定义

> 访问修饰符 static 返回类型 方法名(形式参数) {}
>
> static  访问修饰符 返回类型 方法名(形式参数) {}
>
> 

* 类方法的调用

> 类名.类方法(实际参数)
>
> 对象名.类方法(实际参数)

* 类方法细节

> 可以通过类中定义类方法提高效率
>
> 类方法中不能使用this super 使用对象中的属性和方法
>
> 类方法只能使用静态变量和静态属性
>
> 但非静态方法可以使用静态方法和静态属性
>
> 类方法不能重写
>
> 总结： 静态方法只能访问静态成员 非静态方法可以访问所有成员
>
> 在编写代码时仍要遵守访问权限规则

### 理解main方法的语法

* 深入理main方法

> mian方法时在虚拟机调用
>
> java虚拟机要调用main方法所以访问权限必须是public
>
> java虚拟机在执行main方法时不必创建对象 所以该方法必须是static
>
> 该方法接收String类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数，如          java 执行的程序 参数1 参数2 参数3 
>
> 虚拟机不需要返回值 所以返回类型是void

* main方法细节

> mian方法为静态方法只能访问本类中的静态成员，不能访问本类中的非静态成员
>
> 要想访问本类中的非静态成员，必须先创建对象，再调用成员
>
> main方法中可传递参数字符串数组

### 代码块

* 基本介绍

> 代码块又称初始化代码 是类中的成员 类的一部分 类似于方法 将逻辑语句封装在方法体中 通过{}包围起来
>
> 但和方法不同 没有方法名 没有返回 没有参数 只有方法体 而且不用通过对象或类显示调用 **在加载类时 或创建对象时隐式调用**   加载类时时调用 静态代码块  创建对象时调用 普通代码块 
>
> 注意 第一次创建对象时会加载类 此时 静态代码块和普通代码块都会被调用

* 基本语法

>修饰符 {};
>
>注意：
>
>修饰符只能是static 或者无  
>
>代码块分两类 使用static 的静态代码块 不用static修饰的非静态代码块 （普通代码块）
>
>逻辑语句可以是任何逻辑语句 循环 输出方法调用 判断 等
>
>；可以写上也可以省略
>
>创建对象时 先调用代码块 再调用构造器
>可以理解为代码块是构造器的补充 同时可以解决代码冗余的情况

* 细节

> 1. static x修饰的静态代码块 作用是对类进行初始化   （同静态属性） 它**随着类的加载而执行** 而且**只会执行一次** 如果是普通代码块 每创建一个对象就会执行一次
>
> 2. 第一次创建对象实例时 创建子类对象实例 父类也会加载 使用类的静态成员时 都会加载类
>
> 3. 普通代码块 在创建对象实例时会被调用 也就是说在构造器前面 隐式的调用 创建一次对象 就调用一次 如果调用类的静态成员 只是类被加载 普通代码块不会被调用
>
> 4. 创建一个对象（应是类未被加载时） 在一个类中调用顺序是 调用静态代码块和静态属性初始化（调用静态代码和静态属性初始化优先级一样 如果有多个 则按定义顺序执行） 调用普通的代码块和普通属性的初始化 （他们优先级一样 如果多个 则按顺序执行） 最后调用构造器  总顺序 ： 静态属性或静态代码块->普通属性或普通代码块 -> 构造器（构造器可操作静态属性或非静态属性） 代码块在构造器前被执行
>
> 5. 构造器的最前面其实隐含了super() 和调用普通代码块属性初始化  静态相关的代码块 属性初始化 在类加载时就执行完毕 因此是优先于构造器和普通代码块执行的 （构造器和普通代码块普通属性是在类创建时被调用的）
>
>    ```java
>    class AA {
>        public AA() {
>            super();//继承object类
>            //调用普通代码块 普通属性初始化的工作
>            //构造器内容  属性初始化等
>        }
>    }
>    ```
>
> 6. 继承关系下静态代码块 普通代码块 静态属性 普通属性 构造器在创建一个对象后的调用顺序如下 类加载 ：(1) 父类的静态代码块 和静态属性（优先级一样按定义顺序进行） (2)子类的静态代码块和静态属性 对象创建：(3)父类的普通代码块和普通属性  (4)父类的构造方法 （5）子类的普通代码块和普通属性 （6）子类的构造器   注意 ：这里普通代码块在构造方法之前被调用好像不太严谨 应是先调用构造器 但构造器中先执行super 然后 执行普通代码块 最后执行构造器中的实际内容 表现形式就是普通代码块先被调用
>
>    ```java
>    总结 继承关系下创建一个子类对象发生的过程
>    分为两个阶段 类加载阶段和对象创建阶段
>    
>    类加载阶段 遵循先加载父类然后再加载子类的原则
>    
>    按定义顺序先调用父类的静态属性和静态代码块
>    然后按定义顺序调用子类的静态属性和静态代码块
>    
>    对象创建阶段  先前学习的对象的继承
>    
>    先调用子类的构造器 找到super() 调用父类的构造器
>    父类的super()无参构造器执行完毕后 开始构造器中隐藏的调用方法
>    调用父类的普通属性 和普通代码块 完成后执行父类的构造器
>    父类构造器执行完毕后 返回子类的构造器等于子类的super()执行完成
>    接着执行子类构造器中隐藏的调用方法
>    调用子类的普通属性和普通代码块 
>    完成后执行子类的构造器
>    返回对象引用
>    至此对象创建完毕
>    ```
>
> 7. 静态代码块只能直接调用静态成员(静态属性和静态方法) 普通代码块可以调用任意成员

### 单例设计模式

* 介绍

> 采取一定的方法保证在整个软件系统中，对某个类只能存在一个对象实例 并且该类只提供一个取得其对象实例的方法  单例设计模式有两种 饿汉式 懒汉式

* 饿汉式 (很着急 可能没使用对象就创建) 

> 1. 将构造器私有化
> 2. 在类的内部直接创建对象（静态属性 保证静态方法可以返回 并且只创建一次）
> 3. 提供公共的静态方法返回创建的对象
>
> ```java
> public class Girlfriend {
>     private String name;
>     private int age;
>     private static Girlfriend gf = new Girlfriend("小红",18);//类中创建静态对象
>     private Girlfriend(String name, int age) { //将构造器私有化
>         this.name = name;
>         this.age = age;
>     }
>     public static Girlfriend getGf() {
>         return gf;//公有静态方法返回对象
>     }
> }
> ```

* 懒汉式（使用才创建）

> 1. 将构造器私有化
> 2. 在类的内部直接创建对象引用  （静态属性 保证静态方法可以返回  并且只创建一次）
> 3. 提供公共的静态方法在方法中判断引用是否为空  后创建对象  返回对象
>
> ```java
> public class Cat {
>     private String name;
>     private static Cat cat; //静态创建对象引用 不初始化对象
>     private Cat(String name) { //将构造器私有化
>         this.name = name;
>     }
>     public static Cat getCat() { //通过公共方法返回对象
>         if(cat == null) { //保证只创建一次
>             cat = new Cat("布丁");
>         }
>         return cat;
>     }
> }
> ```

### final关键字 

* 用法

> 修饰类表示该类不可继承
>
> 修饰方法表示该方法不可重写
>
> 修饰属性表示不可修改
>
> 修饰局部变量表示该变量不可修改

* 细节

> 1. final修饰的属性一般又叫做常量 一般用XXX_XX大写字母+ _来命名
> 2. final修饰的常量必须赋初值 并且以后无法修改 赋值可以在定义时 构造器 代码块
> 3. final修饰的常量如果是静态的 定义时必须在 定义时 或 静态代码块 不可在构造器中 
> 4. final类不可以继承 但可以实例化对象的
> 5. 如果不是final类但是含有final方法 继承的子类是可以使用父类final方法的
> 6. 一般来说 如果类定义成final类 就不必要使用final修饰方法了
> 7. final不可修饰构造方法
> 8. final和static往往搭配使用 效率更高 共同修饰属性时产生额外效果 调用该静态属性 不会导致类加载 （编译器底层做了优化处理）
> 9. Integer  Double  Float Boolean String 等包装类都是final类 不可被继承

### 抽象类  

* 介绍

> 父类的方法有时不确定 需要在子类中实现 这时可以将父类定义成抽象类 抽象类中只写方法名 不写方法体 通过继承的子类重写实现  用abstract修饰该方法 该方法就是抽象方法 abstract修饰的类就是抽象类

* 细节

> 1. 抽象类不能被实例化
>
> 2. 抽象类不一定要有抽象方法 而且还可以有实现方法
>
> 3. 一旦类中包含了抽象方法 则这个类必须声明成abstract
>
> 4. abstract只能修饰 类和方法 不能用于修饰属性或其他的
>
> 5. 抽象类还是类 可以有任意成员 比如非抽象方法 构造器 静态属性 非静态属性等
>
> 6. 抽象方法不可有主体
>
> 7. 如果一个类继承了抽象类 则它必须实现抽象类的所有抽象方法 除非它自己也声明成abstract类
>
>    abstract类继承 可不实现抽象方法
>
> 8. 抽象方法不能使用private final static来修饰 因为这些关键字都是和重写相违背的

### 模板设计模式

* 大体描述

> 模板设计模式是基于继承抽象类的基础上的 大致思路是： 在抽象父类中定义一个抽象方法和一个调用该方法的公共方法   子类中实现父类该抽象方法 然后通过创建子类对象 调用父类的那个公共方法  根据动态绑定机制 不同子类实现的抽象方法不同 调用父类公共方法的得到的结果也不同 避免了子类中多次出现父类中的公共方法代码  提高代码的复用性
>
> 下面已计算程序运行时间为例
>
> ```java
> public abstract class Template {
>     public abstract void job();
>     //模板类中实现 计算运算时间
>     public long getListTime() {
>         long start = System.currentTimeMillis();
>         job();
>         long end = System.currentTimeMillis();
>         return (end - start);
>     }
> }
> ```
>
> ```java
> public class AA extends Template {
>     @Override
>     public void job() {
>         long sum = 0;  //AA类中抽象类的实现方法
>         for (int i = 0; i < 100000; i++) {
>             sum += i;
>         }
>     }
> }
> ```
>
> ```java
> public class BB extends Template {
>      @Override
>     public void job() {
>         long sum = 0;  //BB类中抽象类的实现方法
>         for (int i = 0; i < 10000000; i++) {
>             sum += i;
>         }
>     }
> }
> ```

### 接口

* 基本概念

> 接口就是给出一些没有实现的方法 封装到一起 到某个类要使用的时候 在根据具体情况把这些方法写出来  （接口类）

* 语法

> 定义接口  interface 接口名 { 属性 方法 } (jdk 8后可以定义属性和默认实现方法和静态方法 之前只能有抽象方法)
>
> 实现接口 class 类名 im   plements 接口 { 自己属性 自己方法 必须实现接口的抽象方法}

* 接口的用法

> 第一就是规范化调用  现在分为三个类 调用接口类  接口类  接口实现类
>
> 在接口实现类中定义接口 调用接口类的方法中可以传入接口实现类 实现多态参数调用

* 细节

> 1. 接口不能被实例化 和抽象类相似
>
> 2. 接口中所有方法是**public方法** 接口中的抽象方法 可以**不用abstract**修饰
>
> 3. 一个普通类实现接口 必须将所有从抽象方法都实现 （alt + enter）
>
> 4. 抽象类去实现接口时 可以不实现接口的抽象方法
>
> 5. 一个类可以实现多个接口
>
> 6. 接口中的属性 只能是final的 并且是public static final修饰符修饰的
>
> 7. 接口中属性的访问形式 接口名.属性名
>
> 8. 接口不能继承其他类，但可以继承多个别的接口
>
> 9. 接口的修饰符只能是public和默认 这点和类相同
>
> 10. 类实现接口后可以说相当于对单继承机制的补充
>
> 11. 实现接口和继承同时存在时 对于同名属性访问不分优先级 直接同名属性访问编译器会报错
>
>     （实现接口和继承父类等级相近）
>

* 实现接口 和  继承类 的区别

> 子类继承了父类相当于直接获得了父类的功能 如果子类需要扩展功能 可以通过实现接口的方式扩展  总结 实现接口是对java单继承机制的一种补充
>
> 继承的价值主要在于：解决代码的复用性和可维护性 
>
> 接口的价值主要在于：设计 设计好的各种规范(方法) 让其他类区实现这些方法 即更加的灵活
>
> 接口比继承更加灵活： 继承是满足 is - a 的关系 接口是满足like - a 的关系
>
> 接口在一定程度上可以实现代码解耦   [接口规范 + 动态绑定]

* 接口的多态特性 （类比继承）

> 1. 多态参数
>
>     接口（类）可以接收任何实现接口的实现类 即接口的引用指向了接口的类的对象---
>
>    （类比父类的引用指向子类的对象 向上转型）
>
> 2. 多态数组
>
>    接口数组可以存储任何实现接口的实现类  在使用时可以转型成相应的实现类 ---
>
>    （类比向上转型的父类的引用可以重新转换成子类的引用 向下转型）
>
> 3. 多态传递
>
>    一个接口的父类接口的引用可以指向该接口的实现类对象  也就是说实现类实现了两个接口--- 
>
>    (类比向上转型 超类的引用可以指向子类的对象)

### 内部类

* 类的五大成员

> 属性 方法 构造器 代码块 内部类

* 定义语法

> ```java
> class 外部类名 {
>     class 内部类名 {
>      
>     }
> }
> class 外部其他类名 {
> }
> ```

* 内部类的分类

> 1. 定义在外部类局部位置上 （比如方法内）
>    1. 局部内部类（有类名）
>    2. 匿名内部类 （无类名）！！！
> 2. 定义在外部类的成员位置上
>    1. 成员内部类 (没用static修饰)
>    2. 静态内部类 (使用static修饰)

* 局部内部类

> 语法 : class 局部内部类类名 {};
>
> 细节:
>
> 1. 局部内部类是定义在外部类的局部位置  一般是在方法或者是代码块内
>
> 2. 局部内部可以直接访问外部类的所有成员 包括私有的
>
> 3. 不能添加访问修饰符 因为局部内部类的地位就是一个变量 局部变量不能使用访问修饰符 但内部类可以使用final关键字修饰 因为局部变量也能使用final修饰
>
> 4. 局部内部类的作用域只在方法或代码块中  因为它被视为一个局部变量
>
> 5. 局部内部类可以直接访问外部成员  外部类访问内部类成员需要创建内部类对象 
>
>    即在内部类作用域方法内创建对象 然后调用内部类成员即可
>
> 6. 外部其他类不能访问局部内部类 局部内部类被视为局部变量 (但其本质还是类)
>
> 7. 如果外部类和内部类的成员变量重名时 默认遵循就近原则 如果想要访问外部类成员 可以用外部类名.this.成员名   外部类名.this 代表外部调用的类的对象引用  （注意: this代表的当前对象的引用 也就是地址 就是谁调用该方法 this指的对象就是哪个

* 匿名内部类

> 认识: 匿名内部类是定义在外部类的局部位置 比如方法中 并且没有类名 
>
> 匿名内部类 1 本质是类  2 是内部类  3 该类没有名子  4 同时还是一个对象
>
> 语法: new  接口() {};  new 类名(参数列表) {}；共两种 本质上是一种   返回的是匿名类对象
>
> 理解：匿名内部类的本质都是在代码底层创建匿名子类 该子类实现接口的方法 父类的方法 或抽象类的方法  接着直接创建对象 返回对象的引用  用接口类 父类 或抽象类 的引用接收 本质上是向上转型 因为运行类型是子类 根据向java动态绑定机制 可以调用子类重写的方法  实现不创建子类可以直接得到一个子类的对象  提高编程效率
>
> ```java
> // 基于接口的 
> // 需求:
> // 1 使用接口创建对象
> // 2 写一个类 实现该接口 并创建对象
> // 3 该对象只用一次 后面不再使用
> // 4 使用匿名内部类来简化开发
> // 5 jdk底层创建匿名内部类 马上生成了该类的实例对象 返回地址
> // 6 匿名内部类只能使用一次 就不能使用 (即返回地址后就找不到该类了)
> //代码解释：
> class IA {
>  public void method() {
>      //匿名内部类定义在外部类的方法中
>      //编译类型为IB 接口类 运行类型为 底层创建的IA￥类
>      IB rabbit = new IB() {
>          @Override
>          public void cry() {
>              System.out.println("呜啊呜啊");
>          }
>      };//这是一个变量 结束后要加分号
>      /**对匿名内部类分析
>      new IB() {...}相当于 在底层先创建了一个匿名的类 该类名为 IA￥1 并且实现了IB的接口 即
>      class IA$1 implements IB {
>          @Override
>          public void cry() {
>              System.out.println("呜啊呜啊");
>          }
>      }
>       IB rabbit = new IA$1();
>       本质上还是在方法内先创建接口实现类 然后通过创建对象向上转型返回地址
>       */
>      System.out.println(rabbit.getClass()); //该对象的运行类型 IA$1
>      rabbit.cry();
>  }
> }
> ```
>
> ```java
> //基本类的匿名内部类
> //分析
> //1.father 的编译类型是 Father
> //2.father 的运行类型是 IA￥2 该类的第二个匿名内部类
> public void method2() {
>     Father father = new Father("ling") {
>         @Override
>         public void test() {
>             System.out.println("匿名内部类重写了test方法");
>         }
>     }; //创建匿名内部类
>     /**
>      * 解释 (大概)：
>      * new Father(ling) {} 的过程  底层是
>      * class IA$2 extends Father {
>      *     public AI$2(String name) {
>      *         super(name);
>      *     }
>      *    @Override
>      *    public void test() {
>      *    System.out.println("匿名内部类重写了test方法");
>      *  }
>      *  Father father = new IA$2(ling)；
>      *  本质还是向上转型
>      */
>     father.test();//动态绑定机制 绑定运行类型 子类IA$2
>     System.out.println(father.getClass()); //father对象的运行类型为 IA￥2
> }
> ```
>
> ```java
>   //基于抽象类的匿名内部类
>     public void method3() {
>         Mother mother = new Mother() {
>             @Override
>             public void test() {
>                 System.out.println("匿名内部类重写了test方法");
>             }
>         };
>         /**
>          * 解释：
>          * 相当于
>          * class IA$3 extend Mother {
>          *  public void test() {
>          *  system.out.println("匿名内部类重写了test方法")
>          * }
>          * Mother mother = new IA$3();
>          */
>         mother.test();
>         System.out.println(mother.getClass());
>     }
> }
> ```

* 匿名内部类细节

> 1. 匿名内部类返回对象的调用
>    1. 用父类对象引用接收 然后调用
>    2. 在{}后直接调用  即 {}.方法名
> 2. 可以直接访问外部类的所有成员 包含私有的
> 3. 不能添加访问修饰符，因为它的地位就是一个局部变量
> 4. 作用域只有在外部类的成员方法或者代码块中
> 5. 外部其他类不能访问匿名内部类 因为匿名内部类创建一次就消失了(不能创建新的对象)
> 6. 如果外部类和内部类的成员变量重名时 默认遵循就近原则 如果想要访问外部类成员 可以用外部类名.this.成员名   外部类名.this 代表外部调用的类的对象引用  （注意: this代表的当前对象的引用 也就是地址 就是谁调用该方法 this指的对象就是哪个

* 匿名内部类的使用场景

> 1. 可以当做对象(实际参数)直接使用  简洁高效
>
> ```java
> public class Test {
>     public static void main(String[] args) {
> //直接使用匿名内部类作为参数
>         printf(new IB() {
>             @Override
>             public void show() {
>                 System.out.println("用匿名内部类直接作为参数");
>             }
>         });
>         //这里本质上也是创建了一个类IB$1 实现了该接口 重写了该方法 然后返回一个该类的对象
>         //调用传入调用方法时动态绑定该对象的重写的方法 实现多态
>     }
>     public static void printf(IB ib) { //用接口接收 实现多态 一般情况要先实现接口类 类比用父类接收要创建子类
>         ib.show();// 动态绑定直接调用传入对象的show()
>     }
> }
> interface IB {
>     void show();
> }
> ```

* 成员内部类

> 1. 成员内部类是定义在外部类的成员位置上的 并且没有static修饰 （加上就是静态内部类了）
>
> 2. 成员内部类中可以直接访问外部类的所有成员 包含私有的
>
> 3. 可以使用任意访问修饰符 因为它的地位就是一个成员 
>
> 4. 同外部类的其他成员一样 成员内部类的作用域是整个类体
>
> 5. 成员内部类可以直接访问外部类的成员 外部类需先创建成员内部类的对象后访问成员内部类中的成员
>
> 6. 外部其他类使用成员内部类有三种方式
>
>    1. 外部类名.内部类名  创建成员内部类对象名 = 外部类对象名.new 内部类名(参数列表)
>
>       ```java
>       Person.People p1 = person.new People();
>       ```
>
>    2. 在外部类内定义一个方法 在该方法中创建成员内部类的对象  直接返回内部类的对象
>
>       ```java
>       Person.People p2 = person.ret();
>       ```
>
>    3. 将以上两种方法结合 等于说创建的外部类不返回引用 直接一次使用返回内部类
>
>       ```java
>       Person.People p3 = new Person().ret();
>       Person.People p4 = new Person().new People();
>       ```
>
> 7. 如果外部类和内部类的成员变量重名时 默认遵循就近原则 如果想要访问外部类成员 可以用外部类名.this.成员名   外部类名.this 代表外部调用的类的对象引用  （注意: this代表的当前对象的引用 也就是地址 就是谁调用该方法 this指的对象就是哪个

* 静态内部类

> 1. 静态内部类还是定义在外部类成员的位置 只是加上了static修饰符
>
> 2. 可以访问外部类的所有静态成员 包括私有的  不能访问外部类的非静态成员
>
> 3. 可以使用任意访问修饰符 因为它的地位就是一个成员 
>
> 4. 同外部类的其他成员一样 静态内部类的作用域是整个类体
>
> 5. 静态内部类访问外部类成员方式是直接访问 外部类访问内部类的成员方式是先创建对象后放访问
>
> 6. 外部其他类访问内部类的几种方式
>
>    1. 外部类名.内部类名  创建静态内部类的对象名  =  new 外部类名.内外类名(参数);
>
>       ```java
>       Person.People2 p5 = new Person.People2();
>       ```
>
>    2. 在外部类中定义一个方法(静态或非静态)返回创建的静态内部类的实例
>
>       ```java
>       Person.People2 p6 = person.get();  /  Perosn.get();
>       ```
>
> 7. 如果外部类和内部类的成员变量重名时 默认遵循就近原则 如果想要访问外部类成员 可以用外部类名.this.成员名   外部类名.this 代表外部调用的类的对象引用  （注意: this代表的当前对象的引用 也就是地址 就是谁调用该方法 this指的对象就是哪个
