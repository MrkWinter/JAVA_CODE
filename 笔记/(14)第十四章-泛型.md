### 	泛型

* 泛型的介绍

  > 1. 泛型又称参数数据类型 是jdk5.0出现的新特性 解决数据类型的安全性问题
  > 2. 在类声明或实例化对象时只要指定好需要的具体的类型即可
  > 3. 泛型可以保证如果程序在编译时没有发出警告 运行时就不会参数数据类型转换异常 同时代码更加简洁高效
  > 4. 泛型的作用是 可以在类声明时用<标识符>指定一个数据类型 这个标识符可以表示某个属性的数据类型 或者某个方法的返回类型 或者参数类型 总的来说可以把标识符当成一种传入该类的类(数据类型)使用
  > 5. 泛型的数据类型在对象定义时指定 在编译期间 就确定了该数据类型是什么

* 泛型的声明‘

  > interface 接口<T,K>   class 类<V>
  >
  > 创建对象时 甚至用Interator迭代器时 都能使用泛型

* 泛型的细节

  > 1. 泛型 T V K 等指定数据类型时必须是引用类型不能是基本数据类型
  > 2. 在给泛型指定数据类型时 数据可以传入其子类类型 本质是向上转型
  > 3. 如HashMap<String, Student> hashmap = new HashMap<>(); 可以减写后面的<>的内容（编译器自动识别）
  > 4. 若在类中定义泛型后 创建对象不指定泛型时 默认泛型为Object 

* 自定义泛型

  > 1. class 类名<T,R> {  代码中可以使用泛型 } 这里也可以用在接口
  > 2. 普通成员可以使用泛型(属性 方法等)
  > 3. 使用泛型的数组不能初始化
  > 4. 静态成员(静态方法 属性) 不能使用泛型 (泛型在对象创建时指定 静态成员不创建对象就可以使用)
  > 5. 泛型的类型 在创建对象时<>指定
  > 6. 若创建对象时不指定泛型 默认为泛型为Object类型
  > 7. 泛型的标识符一般为单个的大写字母 泛型的表示符可以有多个
  > 8. 接口中静态成员也不能使用泛型
  > 9. 接口泛型的类型在继承接口或者实现接口时实现
  > 10. 类的泛型类型同样可以在子类中指定实现
  > 11. 没有指定类型默认为Object
  
* 自定义泛型方法

  > 1. 声明方法 public<T> void  cry(T t) {};
  > 2. 泛型方法可以定义在普通类中 也可以定义在泛型类中
  > 3. 当泛型方法被调用时 根据传入的参数来确定对应的泛型类型
  > 4. 要分清泛型方法 和 使用泛型的方法 泛型方法是方法中定义了泛型 使用泛型的方法是该方法使用了类或接口定义的泛型
  > 5. 泛型方法 可以使用类声明的泛型 也可以使用泛型
  > 6. 方法自己声明的泛型
  > 7. 泛型就是可以接收数据类型的数据类型

* 泛型继承和通配符说明

  > 1. 泛型不具有继承性
  >
  > 2. ```java
  >    List<Object> list = new LinkedList<String>();
  >    //List<Object>规定了List接口中的泛型为Object LinkedList<String> 规定了//LinkedList类中泛型为String 使用时会发生混乱 故泛型没有继承机制
  >    ```
  >
  > 3. 类名<?> 变量名  表示可以接收任意泛型的该类的实例化对象
  >
  > 4. 类名<？ extends A> 变量名 表示该变量可以接收支持A及其A子类的泛型的该类的实例化对象规定了泛型的上限
  >
  > 5. 类名<? super A> 变量名  表示该变量可以接收支持A类及其A类父类的泛型的该类的实例化对象 规定了泛型的下限

### Junit单元测试框架使用

* 基本使用

  > 1. Junit是一个Java语言的单元测试框架
  > 2. 多数Java的开发环境都已经集成了Junit作为单元测试的工具
  > 3. 通过@Test加入想要测试的代码前 可以直接运行相应的代码 不需要调用
  > 4. 需要通过alt + enter 快捷键来引入相关的包 一般使用版本是5.4